# MyThreadPool
首先需要说明的是该线程池的实现，并不都是我自己写的，基本借用了[ThreadPool](https://github.com/progschj/ThreadPool)的实现。选择它的原因，一方面是它足够轻量级，另一方面是它将C++11部分特性，在线程池的实现上发挥得淋漓尽致。因此，想了解线程池原理的开发人员可以了解一下。当然，如今都已经C++20，C++11部分功能已经落后了，完全使用C++11编写的该库在最新的编译器上已经没法编译通过。所以，我的这个demo就将使用C++17或者C++20（当然也还会有C++11）的新功能重新翻修一下该库（本人水平也有限，不一定写得足够好）。另外，由于C++20部分功能在最新得编译器上并未完全实现，所以为了提前使用到某些库，就使用了别人实现的准标准库，如[jthread](https://github.com/josuttis/jthread)
## 说明
在原库上进行的改动我在头文件里注释出来了，有两个地方在这里进行代码说明一下：  
我写的一个测试例子：
```cpp
int main()
{
    ThreadPool pool(4);
    auto ret1 = pool.enqueue([](int input){ return input;},42);
    auto ret2 = pool.enqueue([ret1](int input){ std::cout << ret1.get() << '\n'; return input}, 46);
    auto ret3 = pool.enqueue([ret2](){std::cout << ret2.get() << '\n';});
    
    return 0;
}
```
原作者为他的库提供了一个简单的使用例子，他是在主线程里调用std::future的get()方法，如果这样做不会有啥问题，而且这种使用方式，也挺正常，我也一直这样使用。不过某一天突发奇想，不在主线程里（准确地说是在pool的作用域里）调用get()，问题就暴露了（之后看过他的issue，确实有人提了类似的问题）。如果不在pool的作用域里调用get()，就不会等待所有线程结束才离开pool的作用域，这样就会造成pool被析构了，线程却依然在执行，那么那些未执行完成的线程就会访问被析构的内存空间，是一种未定义的行为，所以我在ThreadPool的析构函数里加了while的循环（有更优雅的实现方式，我图简单粗暴就直接用while了）。至于为什么使用std::shared_future，我上面的例子也体现了，就是可能会有多个子线程共享future的情况，原作者的想法好像是独立各个子线程的关系，我就想子线程之间也会存在相互共享返回值的情况（我并发编程的经验不够，所以不太清楚这么改动的必要性，所以姑且加上吧，本来改动也不多），所以对此处做了改动。
